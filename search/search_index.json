{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#confound-corrected-connectome-based-predictive-modeling-cccpm","title":"Confound-Corrected Connectome-Based Predictive Modeling (CCCPM)","text":"<p>CCCPM is a newly developed Python toolbox designed specifically for researchers in psychiatry and neuroscience to  perform connectome-based predictive modeling. This package offers a comprehensive framework for building predictive  models from structural and functional connectome data, with a strong focus on methodological rigor, interpretability,  confound control, and statistical robustness.</p>"},{"location":"#background","title":"Background","text":"<p>Network-based approaches are increasingly recognized as essential for understanding the complex relationships in brain connectivity that underlie behavior, cognition, and mental health. In psychiatry and neuroscience, analyzing structural and functional networks can reveal patterns associated with mental disorders, support individualized predictions, and improve our understanding of brain function. However, these analyses require robust tools that account for the unique challenges of connectome data, such as high dimensionality, variability, and the influence of confounding factors.</p> <p>Despite the growing importance of connectome-based predictive modeling (CPM), there is currently no fully developed software package for performing these analyses. Existing options are limited to a few MATLAB scripts, which lack the flexibility, transparency, and rigor required to foster replicable research. CCCPM addresses this gap by providing a Python-based, flexible, and rigorously designed toolbox that encourages replicable analyses while allowing researchers to tailor their workflows to specific research questions.</p>"},{"location":"#overview","title":"Overview","text":"<p>CCCPM was developed to address key challenges in connectome-based analyses, including optimizing model hyperparameters, controlling for confounding variables, and assessing the reliability of selected network features. This toolbox introduces novel methods, such as stability metrics for selected edges, and integrates well-established practices like nested cross-validation and permutation-based significance testing. By doing so, CCCPM provides a powerful and transparent tool for researchers aiming to explore brain networks' contributions to predictive models.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Hyperparameter Optimization: Fine-tune model parameters, such as p-thresholds for edge selection, to achieve better predictive performance.</li> <li>Confound Adjustment: Use partial correlation methods during edge selection to rigorously control for covariates and confounding variables.</li> <li>Residualization: Remove the influence of confounds from connectome strengths to ensure cleaner data inputs.</li> <li>Statistical Validation: Assess model and edge-level significance using permutation-based testing, ensuring that findings are statistically robust.</li> <li>Stability Metrics: Evaluate the reliability of selected edges across iterations, improving the interpretability and reproducibility of identified networks.</li> <li>Model Increment Analysis: Quantify the unique contribution of connectome data to predictive models, helping to clarify their added value in prediction tasks.</li> </ul>"},{"location":"#why-cccpm","title":"Why CCCPM?","text":"<p>Unlike existing CPM implementations, which are limited in scope and flexibility, CCCPM is designed to foster rigorous and replicable research. Its Python-based architecture ensures accessibility and compatibility with modern data science workflows, while its features address the specific challenges of connectome-based analyses. By offering a robust and transparent framework, CCCPM enables researchers to conduct analyses that are not only flexible and customizable but also reproducible and scientifically sound.</p>"},{"location":"#features-in-detail","title":"Features in Detail","text":""},{"location":"#data-imputation","title":"Data Imputation","text":"<p>CCCPM includes methods to handle missing data effectively, ensuring that datasets with incomplete connectome information can still be utilized without introducing biases.</p>"},{"location":"#nested-cross-validation","title":"Nested Cross-Validation","text":"<p>A nested cross-validation scheme is implemented to separate hyperparameter tuning from model evaluation. This ensures that the reported model performance is unbiased and reflects its true generalization capability.</p>"},{"location":"#threshold-optimization","title":"Threshold Optimization","text":"<p>The toolbox automates the optimization of p-thresholds, which determine which edges in the connectome are selected for model building. This allows researchers to identify thresholds that balance performance and interpretability.</p>"},{"location":"#confound-adjustment","title":"Confound Adjustment","text":"<p>By implementing partial correlations, CCCPM allows researchers to account for confounding variables during edge selection, ensuring that identified networks represent genuine relationships rather than artifacts.</p>"},{"location":"#statistical-significance","title":"Statistical Significance","text":"<p>Permutation-based testing is provided to evaluate the significance of both model performance and selected edges, adding rigor to findings and reducing the risk of false-positive results.</p>"},{"location":"#edge-stability","title":"Edge Stability","text":"<p>CCCPM introduces a stability metric for selected edges, helping researchers evaluate the consistency of their findings across multiple iterations. This enhances the reliability of results and their potential for replication.</p>"},{"location":"#model-increment-analysis","title":"Model Increment Analysis","text":"<p>Assess the added predictive value of connectome data by calculating the incremental contribution of network features to overall model performance.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide will help you get started with running an analysis using the <code>CPMRegression</code> class. It provides a step-by-step description of how to set up, configure, and execute an analysis, along with explanations of the inputs and parameters.</p>"},{"location":"getting_started/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>To run an analysis, you need the following inputs:</p> <ul> <li>Connectome Data (<code>X</code>): A 2D array (numpy array or pandas DataFrame) of shape <code>(n_samples, n_features)</code> containing connectome edge values for each subject.</li> <li>Target Variable (<code>y</code>): A 1D array or pandas Series of shape <code>(n_samples,)</code> containing the outcome variable (e.g., clinical scores, behavioral measures).</li> <li>Covariates: A 2D array or pandas DataFrame of shape <code>(n_samples, n_covariates)</code> containing variables to control for (e.g., age, sex).</li> </ul> <p>Ensure that all inputs have consistent sample sizes (<code>n_samples</code>).</p>"},{"location":"getting_started/#step-2-configure-the-analysis","title":"Step 2: Configure the Analysis","text":""},{"location":"getting_started/#cross-validation","title":"Cross-Validation","text":"<p>The <code>CPMRegression</code> class uses an outer cross-validation loop for performance evaluation and an optional inner cross-validation loop for hyperparameter optimization.</p> <ul> <li>Outer CV (<code>cv</code>): Defines the cross-validation strategy (e.g., <code>KFold</code>).</li> <li>Inner CV (<code>inner_cv</code>): Used for optimizing hyperparameters during edge selection. Can be left as <code>None</code> if not needed.</li> </ul> <p>Example:</p> Python<pre><code>from sklearn.model_selection import KFold\n\nouter_cv = KFold(n_splits=10, shuffle=True, random_state=42)\n</code></pre>"},{"location":"getting_started/#edge-selection","title":"Edge Selection","text":"<p>The toolbox implements univariate edge selection, allowing users to specify the method for evaluating and selecting edges based on statistical tests.</p>"},{"location":"getting_started/#edge-statistics","title":"Edge Statistics","text":"<p>Choose from the following methods for computing edge statistics:</p> <ul> <li>pearson: Pearson correlation</li> <li>pearson_partial: Pearson partial correlation (controlling for covariates)</li> <li>spearman: Spearman rank correlation</li> <li>spearman_partial: Spearman partial correlation (controlling for covariates)</li> </ul>"},{"location":"getting_started/#p-thresholds","title":"p-Thresholds","text":"<ul> <li>Set a single value (e.g., 0.05) or provide multiple values (e.g., [0.01, 0.05, 0.1]).</li> <li>If multiple thresholds are specified, the toolbox will optimize for the best p-threshold during inner cross-validation.</li> </ul>"},{"location":"getting_started/#fdr-correction","title":"FDR Correction","text":"<ul> <li>Optional FDR correction for multiple comparisons can be applied using correction='fdr_by'.</li> </ul> <p>Example:</p> Python<pre><code>from cpm.edge_selection import UnivariateEdgeSelection, PThreshold\n\nedge_statistic = 'pearson'\nunivariate_edge_selection = UnivariateEdgeSelection(\n    edge_statistic=[edge_statistic],\n    edge_selection=[PThreshold(threshold=[0.05], correction=['fdr_by'])]\n)\n</code></pre>"},{"location":"getting_started/#step-3-set-up-the-cpmregression-object","title":"Step 3: Set Up the CPMRegression Object","text":"<p>Create an instance of the CPMRegression class with the required inputs:</p> Python<pre><code>from cpm.cpm_analysis import CPMRegression\n\ncpm = CPMRegression(\n    results_directory=\"results/\",\n    cv=outer_cv,\n    inner_cv=inner_cv,  # Optional\n    edge_selection=univariate_edge_selection,\n    select_stable_edges=True,\n    stability_threshold=0.8,\n    impute_missing_values=True,\n    n_permutations=100\n)\n</code></pre>"},{"location":"getting_started/#key-parameters","title":"Key Parameters","text":"<ul> <li>results_directory: Directory where results will be saved.</li> <li>cv: Outer cross-validation strategy.</li> <li>inner_cv: Inner cross-validation strategy for hyperparameter optimization (optional).</li> <li>edge_selection: Configuration for univariate edge selection.</li> <li>select_stable_edges: Whether to select stable edges across folds (True or False).</li> <li>stability_threshold: Minimum proportion of folds in which an edge must be selected to be considered stable.</li> <li>impute_missing_values: Whether to impute missing values (True or False).</li> <li>n_permutations: Number of permutations for permutation testing.</li> </ul>"},{"location":"getting_started/#step-4-run-the-analysis","title":"Step 4: Run the Analysis","text":"<p>Call the estimate method to perform the analysis:</p> Python<pre><code>X = ...  # Load your connectome data (numpy array or pandas DataFrame)\ny = ...  # Load your target variable (numpy array or pandas Series)\ncovariates = ...  # Load your covariates (numpy array or pandas DataFrame)\n\ncpm.run(X=X, y=y, covariates=covariates)\n</code></pre> <p>This will:</p> <ol> <li>Perform edge selection based on the specified method and thresholds.</li> <li>Train and evaluate models for each cross-validation fold.</li> <li>Save results, including predictions, metrics, and permutation-based significance tests, to the results_directory.</li> </ol>"},{"location":"getting_started/#step-5-review-results","title":"Step 5: Review Results","text":"<p>After the analysis, you can find the results in the results_directory, including:</p> <ul> <li>Cross-validation metrics (e.g., mean absolute error, R\u00b2).</li> <li>Model predictions for each fold.</li> <li>Edge stability and significance.</li> </ul> <p>You can load and inspect these results for further analysis.</p> <p>By following these steps, you can quickly set up and execute a connectome-based predictive modeling analysis using the CPMRegression class. For further customization, refer to the API documentation.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>Follow these steps to install the ccCPM Python package directly from GitHub.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>tested with Python 3.10 or later</li> <li><code>pip</code> (Python's package manager)</li> </ul>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":"<p>Clone the GitHub repository:</p> Bash<pre><code>git clone https://github.com/mmll/cpm_python.git\n</code></pre> <p>Navigate to the repository directory:</p> Bash<pre><code>cd cpm_python\n</code></pre> <p>Install the package:</p> Bash<pre><code>pip install .\n</code></pre> <p>To install in development mode, use:</p> Bash<pre><code>pip install -e .\n</code></pre> <p>Verify the installation:</p> Python<pre><code>import cpm\nprint(cpm.__version__)\n</code></pre> <p>You should see the package version printed without errors.</p>"},{"location":"api/cpm_regression/","title":"CPM Regression","text":""},{"location":"api/cpm_regression/#cpm.cpm_analysis.CPMRegression","title":"<code>CPMRegression</code>","text":"<p>This class handles the process of performing CPM Regression with cross-validation and permutation testing.</p>"},{"location":"api/cpm_regression/#cpm.cpm_analysis.CPMRegression.__init__","title":"<code>__init__(results_directory, cv=KFold(n_splits=10, shuffle=True, random_state=42), inner_cv=None, edge_selection=UnivariateEdgeSelection(edge_statistic='pearson', edge_selection=[PThreshold(threshold=[0.05], correction=[None])]), select_stable_edges=False, stability_threshold=0.8, impute_missing_values=True, n_permutations=0, atlas_labels=None)</code>","text":"<p>Initialize the CPMRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>results_directory</code> <code>str</code> <p>Directory to save results.</p> required <code>cv</code> <code>Union[BaseCrossValidator, BaseShuffleSplit]</code> <p>Outer cross-validation strategy.</p> <code>KFold(n_splits=10, shuffle=True, random_state=42)</code> <code>inner_cv</code> <code>Union[BaseCrossValidator, BaseShuffleSplit]</code> <p>Inner cross-validation strategy for edge selection.</p> <code>None</code> <code>edge_selection</code> <code>UnivariateEdgeSelection</code> <p>Method for edge selection.</p> <code>UnivariateEdgeSelection(edge_statistic='pearson', edge_selection=[PThreshold(threshold=[0.05], correction=[None])])</code> <code>impute_missing_values</code> <code>bool</code> <p>Whether to impute missing values.</p> <code>True</code> <code>n_permutations</code> <code>int</code> <p>Number of permutations to run for permutation testing.</p> <code>0</code> <code>atlas_labels</code> <code>str</code> <p>CSV file containing atlas and regions labels.</p> <code>None</code>"},{"location":"api/cpm_regression/#cpm.cpm_analysis.CPMRegression.run","title":"<code>run(X, y, covariates)</code>","text":"<p>Estimates a model using the provided data and conducts permutation testing. This method first fits the model to the actual data and subsequently performs estimation on permuted data for a specified number of permutations. Finally, it calculates permutation results.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[DataFrame, ndarray]</code> required <code>y</code> <code>Union[Series, DataFrame, ndarray]</code> required <code>covariates</code> <code>Union[Series, DataFrame, ndarray]</code> required"},{"location":"api/edge_selection/","title":"Edge Selection","text":""},{"location":"api/edge_selection/#cpm.edge_selection.PThreshold","title":"<code>PThreshold</code>","text":"<p>               Bases: <code>BaseEdgeSelector</code></p>"},{"location":"api/edge_selection/#cpm.edge_selection.PThreshold.__init__","title":"<code>__init__(threshold=0.05, correction=None)</code>","text":"<p>:param threshold: :param correction: can be one of statsmodels methods                     bonferroni : one-step correction                     sidak : one-step correction                     holm-sidak : step down method using Sidak adjustments                     holm : step-down method using Bonferroni adjustments                     simes-hochberg : step-up method (independent)                     hommel : closed method based on Simes tests (non-negative)                     fdr_bh : Benjamini/Hochberg (non-negative)                     fdr_by : Benjamini/Yekutieli (negative)                     fdr_tsbh : two stage fdr correction (non-negative)                     fdr_tsbky : two stage fdr correction (non-negative)</p>"},{"location":"api/fold/","title":"Fold","text":""},{"location":"api/fold/#cpm.fold.run_inner_folds","title":"<code>run_inner_folds(X, y, covariates, inner_cv, edge_selection, results_directory, perm_run)</code>","text":"<p>Run inner cross-validation over all folds and hyperparameter configurations.</p> <p>Returns:</p> Name Type Description <code>cv_results</code> <code>DataFrame</code> <p>Aggregated results from all inner folds.</p> <code>stability_edges</code> <code>dict</code> <p>Dictionary with 'positive' and 'negative' keys mapping to arrays of edge stability scores.</p>"},{"location":"api/models/","title":"Predictive Models","text":""},{"location":"api/models/#cpm.models.LinearCPMModel","title":"<code>LinearCPMModel</code>","text":"<p>Linear Connectome-based Predictive Modeling (CPM) implementation.</p> <p>This class implements a linear CPM model, allowing for fitting and prediction based on connectome data, covariates, and residuals.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>ModelDict</code> <p>A dictionary containing the fitted models for different networks and data types (connectome, covariates, residuals, and full model).</p> <code>models_residuals</code> <code>dict</code> <p>A dictionary storing linear regression models used to calculate residuals for connectome data, controlling for covariates.</p> <code>edges</code> <code>dict</code> <p>A dictionary defining the edges (features) used for each network (e.g., 'positive', 'negative').</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>dict</code> <p>Dictionary containing indices of edges for 'positive' and 'negative' networks.</p> required"},{"location":"api/models/#cpm.models.LinearCPMModel.__init__","title":"<code>__init__(edges)</code>","text":"<p>Initialize the LinearCPMModel.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>dict</code> <p>Dictionary containing indices of edges for 'positive' and 'negative' networks.</p> required"},{"location":"api/models/#cpm.models.LinearCPMModel.fit","title":"<code>fit(X, y, covariates)</code>","text":"<p>Fit the CPM model.</p> <p>This method fits multiple linear regression models for the connectome, covariates, residuals, and full model using the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) representing the connectome data.</p> required <code>y</code> <code>ndarray</code> <p>A 1D array of shape (n_samples,) representing the target variable.</p> required <code>covariates</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_covariates) representing the covariates.</p> required <p>Returns:</p> Type Description <code>LinearCPMModel</code> <p>The fitted CPM model instance.</p>"},{"location":"api/models/#cpm.models.LinearCPMModel.predict","title":"<code>predict(X, covariates)</code>","text":"<p>Predict using the fitted CPM model.</p> <p>This method generates predictions for the target variable using the connectome, covariates, residuals, and full models.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) representing the connectome data.</p> required <code>covariates</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_covariates) representing the covariates.</p> required <p>Returns:</p> Type Description <code>ModelDict</code> <p>A dictionary containing predictions for each network and model type (connectome, covariates, residuals, and full model).</p>"},{"location":"examples/human_connectome_project/","title":"HCP","text":"Python"},{"location":"examples/simulated_data/","title":"Simulated Data","text":"Python"}]}