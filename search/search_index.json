{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#confound-corrected-connectome-based-predictive-modeling-cccpm","title":"Confound-Corrected Connectome-Based Predictive Modeling (CCCPM)","text":"<p>CCCPM is a newly developed Python toolbox designed specifically for researchers in psychiatry and neuroscience to  perform connectome-based predictive modeling. This package offers a comprehensive framework for building predictive  models from structural and functional connectome data, with a strong focus on methodological rigor, interpretability,  confound control, and statistical robustness.</p>"},{"location":"#background","title":"Background","text":"<p>Network-based approaches are increasingly recognized as essential for understanding the complex relationships in brain connectivity that underlie behavior, cognition, and mental health. In psychiatry and neuroscience, analyzing structural and functional networks can reveal patterns associated with mental disorders, support individualized predictions, and improve our understanding of brain function. However, these analyses require robust tools that account for the unique challenges of connectome data, such as high dimensionality, variability, and the influence of confounding factors.</p> <p>Despite the growing importance of connectome-based predictive modeling (CPM), there is currently no fully developed software package for performing these analyses. Existing options are limited to a few MATLAB scripts, which lack the flexibility, transparency, and rigor required to foster replicable research. CCCPM addresses this gap by providing a Python-based, flexible, and rigorously designed toolbox that encourages replicable analyses while allowing researchers to tailor their workflows to specific research questions.</p>"},{"location":"#overview","title":"Overview","text":"<p>CCCPM was developed to address key challenges in connectome-based analyses, including optimizing model hyperparameters, controlling for confounding variables, and assessing the reliability of selected network features. This toolbox introduces novel methods, such as stability metrics for selected edges, and integrates well-established practices like nested cross-validation and permutation-based significance testing. By doing so, CCCPM provides a powerful and transparent tool for researchers aiming to explore brain networks' contributions to predictive models.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Hyperparameter Optimization: Fine-tune model parameters, such as p-thresholds for edge selection, to achieve better predictive performance.</li> <li>Confound Adjustment: Use partial correlation methods during edge selection to rigorously control for covariates and confounding variables.</li> <li>Residualization: Remove the influence of confounds from connectome strengths to ensure cleaner data inputs.</li> <li>Statistical Validation: Assess model and edge-level significance using permutation-based testing, ensuring that findings are statistically robust.</li> <li>Stability Metrics: Evaluate the reliability of selected edges across iterations, improving the interpretability and reproducibility of identified networks.</li> <li>Model Increment Analysis: Quantify the unique contribution of connectome data to predictive models, helping to clarify their added value in prediction tasks.</li> </ul>"},{"location":"#why-cccpm","title":"Why CCCPM?","text":"<p>Unlike existing CPM implementations, which are limited in scope and flexibility, CCCPM is designed to foster rigorous and replicable research. Its Python-based architecture ensures accessibility and compatibility with modern data science workflows, while its features address the specific challenges of connectome-based analyses. By offering a robust and transparent framework, CCCPM enables researchers to conduct analyses that are not only flexible and customizable but also reproducible and scientifically sound.</p>"},{"location":"#features-in-detail","title":"Features in Detail","text":""},{"location":"#data-imputation","title":"Data Imputation","text":"<p>CCCPM includes methods to handle missing data effectively, ensuring that datasets with incomplete connectome information can still be utilized without introducing biases.</p>"},{"location":"#nested-cross-validation","title":"Nested Cross-Validation","text":"<p>A nested cross-validation scheme is implemented to separate hyperparameter tuning from model evaluation. This ensures that the reported model performance is unbiased and reflects its true generalization capability.</p>"},{"location":"#threshold-optimization","title":"Threshold Optimization","text":"<p>The toolbox automates the optimization of p-thresholds, which determine which edges in the connectome are selected for model building. This allows researchers to identify thresholds that balance performance and interpretability.</p>"},{"location":"#confound-adjustment","title":"Confound Adjustment","text":"<p>By implementing partial correlations, CCCPM allows researchers to account for confounding variables during edge selection, ensuring that identified networks represent genuine relationships rather than artifacts.</p>"},{"location":"#statistical-significance","title":"Statistical Significance","text":"<p>Permutation-based testing is provided to evaluate the significance of both model performance and selected edges, adding rigor to findings and reducing the risk of false-positive results.</p>"},{"location":"#edge-stability","title":"Edge Stability","text":"<p>CCCPM introduces a stability metric for selected edges, helping researchers evaluate the consistency of their findings across multiple iterations. This enhances the reliability of results and their potential for replication.</p>"},{"location":"#model-increment-analysis","title":"Model Increment Analysis","text":"<p>Assess the added predictive value of connectome data by calculating the incremental contribution of network features to overall model performance.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide will help you get started with running an analysis using the <code>CPMRegression</code> class. It provides a step-by-step description of how to set up, configure, and execute an analysis, along with explanations of the inputs and parameters.</p>"},{"location":"getting_started/#step-1-prepare-your-data","title":"Step 1: Prepare Your Data","text":"<p>To run an analysis, you need the following inputs:</p> <ul> <li>Connectome Data (<code>X</code>): A 2D array (numpy array or pandas DataFrame) of shape <code>(n_samples, n_features)</code> containing connectome edge values for each subject.</li> <li>Target Variable (<code>y</code>): A 1D array or pandas Series of shape <code>(n_samples,)</code> containing the outcome variable (e.g., clinical scores, behavioral measures).</li> <li>Covariates: A 2D array or pandas DataFrame of shape <code>(n_samples, n_covariates)</code> containing variables to control for (e.g., age, sex).</li> </ul> <p>Ensure that all inputs have consistent sample sizes (<code>n_samples</code>).</p>"},{"location":"getting_started/#step-2-configure-the-analysis","title":"Step 2: Configure the Analysis","text":""},{"location":"getting_started/#cross-validation","title":"Cross-Validation","text":"<p>The <code>CPMRegression</code> class uses an outer cross-validation loop for performance evaluation and an optional inner cross-validation loop for hyperparameter optimization.</p> <ul> <li>Outer CV (<code>cv</code>): Defines the cross-validation strategy (e.g., <code>KFold</code>).</li> <li>Inner CV (<code>inner_cv</code>): Used for optimizing hyperparameters during edge selection. Can be left as <code>None</code> if not needed.</li> </ul> <p>Example:</p> Python<pre><code>from sklearn.model_selection import KFold\n\nouter_cv = KFold(n_splits=10, shuffle=True, random_state=42)\n</code></pre>"},{"location":"getting_started/#edge-selection","title":"Edge Selection","text":"<p>The toolbox implements univariate edge selection, allowing users to specify the method for evaluating and selecting edges based on statistical tests.</p>"},{"location":"getting_started/#edge-statistics","title":"Edge Statistics","text":"<p>Choose from the following methods for computing edge statistics:</p> <ul> <li>pearson: Pearson correlation</li> <li>pearson_partial: Pearson partial correlation (controlling for covariates)</li> <li>spearman: Spearman rank correlation</li> <li>spearman_partial: Spearman partial correlation (controlling for covariates)</li> </ul>"},{"location":"getting_started/#p-thresholds","title":"p-Thresholds","text":"<ul> <li>Set a single value (e.g., 0.05) or provide multiple values (e.g., [0.01, 0.05, 0.1]).</li> <li>If multiple thresholds are specified, the toolbox will optimize for the best p-threshold during inner cross-validation.</li> </ul>"},{"location":"getting_started/#fdr-correction","title":"FDR Correction","text":"<ul> <li>Optional FDR correction for multiple comparisons can be applied using correction='fdr_by'.</li> </ul> <p>Example:</p> Python<pre><code>from src.cccpm.edge_selection import UnivariateEdgeSelection, PThreshold\n\nedge_statistic = 'pearson'\nunivariate_edge_selection = UnivariateEdgeSelection(\n    edge_statistic=[edge_statistic],\n    edge_selection=[PThreshold(threshold=[0.05], correction=['fdr_by'])]\n)\n</code></pre>"},{"location":"getting_started/#step-3-set-up-the-cpmregression-object","title":"Step 3: Set Up the CPMRegression Object","text":"<p>Create an instance of the CPMRegression class with the required inputs:</p> Python<pre><code>from src.cccpm.cpm_analysis import CPMRegression\n\ncpm = CPMRegression(\n    results_directory=\"results/\",\n    cv=outer_cv,\n    inner_cv=inner_cv,  # Optional\n    edge_selection=univariate_edge_selection,\n    select_stable_edges=True,\n    stability_threshold=0.8,\n    impute_missing_values=True,\n    n_permutations=100\n)\n</code></pre>"},{"location":"getting_started/#key-parameters","title":"Key Parameters","text":"<ul> <li>results_directory: Directory where results will be saved.</li> <li>cv: Outer cross-validation strategy.</li> <li>inner_cv: Inner cross-validation strategy for hyperparameter optimization (optional).</li> <li>edge_selection: Configuration for univariate edge selection.</li> <li>select_stable_edges: Whether to select stable edges across folds (True or False).</li> <li>stability_threshold: Minimum proportion of folds in which an edge must be selected to be considered stable.</li> <li>impute_missing_values: Whether to impute missing values (True or False).</li> <li>n_permutations: Number of permutations for permutation testing.</li> </ul>"},{"location":"getting_started/#step-4-run-the-analysis","title":"Step 4: Run the Analysis","text":"<p>Call the estimate method to perform the analysis:</p> Python<pre><code>X = ...  # Load your connectome data (numpy array or pandas DataFrame)\ny = ...  # Load your target variable (numpy array or pandas Series)\ncovariates = ...  # Load your covariates (numpy array or pandas DataFrame)\n\ncpm.run(X=X, y=y, covariates=covariates)\n</code></pre> <p>This will:</p> <ol> <li>Perform edge selection based on the specified method and thresholds.</li> <li>Train and evaluate models for each cross-validation fold.</li> <li>Save results, including predictions, metrics, and permutation-based significance tests, to the results_directory.</li> </ol>"},{"location":"getting_started/#step-5-review-results","title":"Step 5: Review Results","text":"<p>After the analysis, you can find the results in the results_directory, including:</p> <ul> <li>Cross-validation metrics (e.g., mean absolute error, R\u00b2).</li> <li>Model predictions for each fold.</li> <li>Edge stability and significance.</li> </ul> <p>You can load and inspect these results for further analysis.</p> <p>By following these steps, you can quickly set up and execute a connectome-based predictive modeling analysis using the CPMRegression class. For further customization, refer to the API documentation.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>Follow these steps to install the CCCPM Python package via pip.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>tested with Python 3.10 or later</li> <li><code>pip</code> (Python's package manager)</li> </ul>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":"<p>CCCPM is available on PyPI. To install, run these commands in your terminal:</p> Bash<pre><code>pip install cccpm\n</code></pre>"},{"location":"api/cpm_regression/","title":"CPM Regression","text":""},{"location":"api/cpm_regression/#cccpm.cpm_analysis.CPMRegression","title":"<code>CPMRegression</code>","text":"<p>This class handles the process of performing CPM Regression with cross-validation and permutation testing.</p>"},{"location":"api/cpm_regression/#cccpm.cpm_analysis.CPMRegression.__init__","title":"<code>__init__(results_directory, cpm_model=LinearCPMModel, cv=KFold(n_splits=10, shuffle=True, random_state=42), inner_cv=None, edge_selection=UnivariateEdgeSelection(edge_statistic='pearson', edge_selection=[PThreshold(threshold=[0.05], correction=[None])]), select_stable_edges=False, stability_threshold=0.8, impute_missing_values=True, calculate_residuals=False, n_permutations=0, atlas_labels=None)</code>","text":"<p>Initialize the CPMRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>results_directory</code> <code>str</code> <p>Directory to save results.</p> required <code>cv</code> <code>Union[BaseCrossValidator, BaseShuffleSplit, RepeatedKFold, StratifiedKFold]</code> <p>Outer cross-validation strategy.</p> <code>KFold(n_splits=10, shuffle=True, random_state=42)</code> <code>inner_cv</code> <code>Union[BaseCrossValidator, BaseShuffleSplit, RepeatedKFold, StratifiedKFold]</code> <p>Inner cross-validation strategy for edge selection.</p> <code>None</code> <code>edge_selection</code> <code>UnivariateEdgeSelection</code> <p>Method for edge selection.</p> <code>UnivariateEdgeSelection(edge_statistic='pearson', edge_selection=[PThreshold(threshold=[0.05], correction=[None])])</code> <code>impute_missing_values</code> <code>bool</code> <p>Whether to impute missing values.</p> <code>True</code> <code>n_permutations</code> <code>int</code> <p>Number of permutations to run for permutation testing.</p> <code>0</code> <code>atlas_labels</code> <code>str</code> <p>CSV file containing atlas and regions labels.</p> <code>None</code>"},{"location":"api/cpm_regression/#cccpm.cpm_analysis.CPMRegression.run","title":"<code>run(X, y, covariates)</code>","text":"<p>Estimates a model using the provided data and conducts permutation testing. This method first fits the model to the actual data and subsequently performs estimation on permuted data for a specified number of permutations. Finally, it calculates permutation results.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[DataFrame, ndarray]</code> required <code>y</code> <code>Union[Series, DataFrame, ndarray]</code> required <code>covariates</code> <code>Union[Series, DataFrame, ndarray]</code> required"},{"location":"api/edge_selection/","title":"Edge Selection","text":""},{"location":"api/edge_selection/#cccpm.edge_selection.PThreshold","title":"<code>PThreshold</code>","text":"<p>               Bases: <code>BaseEdgeSelector</code></p>"},{"location":"api/edge_selection/#cccpm.edge_selection.PThreshold.__init__","title":"<code>__init__(threshold=0.05, correction=None)</code>","text":"<p>:param threshold: :param correction: can be one of statsmodels methods                     bonferroni : one-step correction                     sidak : one-step correction                     holm-sidak : step down method using Sidak adjustments                     holm : step-down method using Bonferroni adjustments                     simes-hochberg : step-up method (independent)                     hommel : closed method based on Simes tests (non-negative)                     fdr_bh : Benjamini/Hochberg (non-negative)                     fdr_by : Benjamini/Yekutieli (negative)                     fdr_tsbh : two stage fdr correction (non-negative)                     fdr_tsbky : two stage fdr correction (non-negative)</p>"},{"location":"api/fold/","title":"Fold","text":""},{"location":"api/fold/#cccpm.fold.run_inner_folds","title":"<code>run_inner_folds(cpm_model, X, y, covariates, inner_cv, edge_selection, results_directory, perm_run)</code>","text":"<p>Run inner cross-validation over all folds and hyperparameter configurations.</p> <p>Returns:</p> Name Type Description <code>cv_results</code> <code>DataFrame</code> <p>Aggregated results from all inner folds.</p> <code>stability_edges</code> <code>dict</code> <p>Dictionary with 'positive' and 'negative' keys mapping to arrays of edge stability scores.</p>"},{"location":"api/models/","title":"Predictive Models","text":""},{"location":"api/models/#cccpm.models.LinearCPMModel","title":"<code>LinearCPMModel</code>","text":"<p>Linear Connectome-based Predictive Modeling (CPM) implementation.</p> <p>This class implements a linear CPM model, allowing for fitting and prediction based on connectome data, covariates, and residuals.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>ModelDict</code> <p>A dictionary containing the fitted models for different networks and data types (connectome, covariates, residuals, and full model).</p> <code>models_residuals</code> <code>dict</code> <p>A dictionary storing linear regression models used to calculate residuals for connectome data, controlling for covariates.</p> <code>edges</code> <code>dict</code> <p>A dictionary defining the edges (features) used for each network (e.g., 'positive', 'negative').</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>dict</code> <p>Dictionary containing indices of edges for 'positive' and 'negative' networks.</p> required"},{"location":"api/models/#cccpm.models.LinearCPMModel.__init__","title":"<code>__init__(edges)</code>","text":"<p>Initialize the LinearCPMModel.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>dict</code> <p>Dictionary containing indices of edges for 'positive' and 'negative' networks.</p> required"},{"location":"api/models/#cccpm.models.LinearCPMModel.fit","title":"<code>fit(X, y, covariates)</code>","text":"<p>Fit the CPM model.</p> <p>This method fits multiple linear regression models for the connectome, covariates, residuals, and full model using the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) representing the connectome data.</p> required <code>y</code> <code>ndarray</code> <p>A 1D array of shape (n_samples,) representing the target variable.</p> required <code>covariates</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_covariates) representing the covariates.</p> required <p>Returns:</p> Type Description <code>LinearCPMModel</code> <p>The fitted CPM model instance.</p>"},{"location":"api/models/#cccpm.models.LinearCPMModel.predict","title":"<code>predict(X, covariates)</code>","text":"<p>Predict using the fitted CPM model.</p> <p>This method generates predictions for the target variable using the connectome, covariates, residuals, and full models.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_features) representing the connectome data.</p> required <code>covariates</code> <code>ndarray</code> <p>A 2D array of shape (n_samples, n_covariates) representing the covariates.</p> required <p>Returns:</p> Type Description <code>ModelDict</code> <p>A dictionary containing predictions for each network and model type (connectome, covariates, residuals, and full model).</p>"},{"location":"api/results_manager/","title":"Results Manager","text":""},{"location":"api/results_manager/#cccpm.results_manager.PermutationManager","title":"<code>PermutationManager</code>","text":""},{"location":"api/results_manager/#cccpm.results_manager.PermutationManager.calculate_p_values","title":"<code>calculate_p_values(true_results, perms)</code>  <code>staticmethod</code>","text":"<p>Calculate p-values based on true results and permutation results.</p> <p>:param true_results: DataFrame with the true results. :param perms: DataFrame with the permutation results. :return: DataFrame with the calculated p-values.</p>"},{"location":"api/results_manager/#cccpm.results_manager.PermutationManager.calculate_p_values_edges_fdr","title":"<code>calculate_p_values_edges_fdr(true_stability, permutation_stability)</code>  <code>staticmethod</code>","text":"<p>Calculate FDR-corrected p-values for each edge in a connectivity matrix using permutation-based empirical p-values and the Benjamini\u2013Yekutieli procedure.</p> <p>For each edge, an empirical p-value is calculated by comparing the true stability score to the distribution of permuted scores at the same edge. The Benjamini\u2013Yekutieli (BY) method is then applied to correct for multiple comparisons, controlling the false discovery rate (FDR).</p> <p>Parameters:</p> Name Type Description Default <code>true_stability</code> <code>ndarray of shape (n_regions, n_regions)</code> <p>Symmetric matrix containing the observed stability scores for each edge.</p> required <code>permutation_stability</code> <code>ndarray of shape (n_permutations, n_regions, n_regions)</code> <p>Array containing stability scores from each permutation run. Each entry is a symmetric matrix of the same shape as <code>true_stability</code>.</p> required <p>Returns:</p> Name Type Description <code>sig_stability</code> <code>ndarray of shape (n_regions, n_regions)</code> <p>Symmetric matrix of FDR-corrected p-values for each edge, calculated by first computing empirical p-values and then applying the Benjamini\u2013Yekutieli correction to control the expected false discovery rate across all edges.</p>"},{"location":"api/results_manager/#cccpm.results_manager.PermutationManager.calculate_p_values_edges_max_value","title":"<code>calculate_p_values_edges_max_value(true_stability, permutation_stability)</code>  <code>staticmethod</code>","text":"<p>Calculate empirical p-values for each edge in a connectivity matrix using the max-value method from permutation testing.</p> <p>For each permutation, the maximum value across all edges is taken to construct a max-null distribution. Each true edge value is then compared to this distribution to compute a p-value, which controls the family-wise error rate (FWER).</p> <p>Parameters:</p> Name Type Description Default <code>true_stability</code> <code>ndarray of shape (n_regions, n_regions)</code> <p>Symmetric matrix containing the observed stability scores for each edge.</p> required <code>permutation_stability</code> <code>ndarray of shape (n_permutations, n_regions, n_regions)</code> <p>Array containing stability scores from each permutation run. Each entry is a symmetric matrix of the same shape as <code>true_stability</code>.</p> required <p>Returns:</p> Name Type Description <code>sig_stability</code> <code>ndarray of shape (n_regions, n_regions)</code> <p>Symmetric matrix of empirical p-values for each edge, calculated by comparing the true stability values to the max null distribution. The p-values reflect the probability of observing a value as extreme or more extreme under the null. Family-wise error is controlled via the max-statistic method.</p>"},{"location":"api/results_manager/#cccpm.results_manager.PermutationManager.calculate_permutation_results","title":"<code>calculate_permutation_results(results_directory, logger)</code>  <code>staticmethod</code>","text":"<p>Calculate and save the permutation test results.</p> <p>:param results_directory: Directory where the results are saved.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager","title":"<code>ResultsManager</code>","text":"<p>A class to handle the aggregation, formatting, and saving of results.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory where results will be saved.</p> required"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.calculate_edge_stability","title":"<code>calculate_edge_stability(write=True, best_param_id=None)</code>","text":"<p>Calculate and save edge stability and overlap.</p> <p>:param cv_edges: Cross-validation edges. :param results_directory: Directory to save the results.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.calculate_final_cv_results","title":"<code>calculate_final_cv_results()</code>","text":"<p>Calculate mean and standard deviation of cross-validation results and save to CSV.</p> <p>:param cv_results: DataFrame with cross-validation results. :param results_directory: Directory to save the results. :return: Updated cross-validation results DataFrame.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.calculate_model_increments","title":"<code>calculate_model_increments()</code>","text":"<p>Calculate model increments comparing full model to a baseline.</p> <p>:param cv_results: Cross-validation results. :param metrics: List of metrics to calculate. :return: Cross-validation results with increments.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.initialize_edges","title":"<code>initialize_edges(n_folds, n_features, n_params=None)</code>  <code>staticmethod</code>","text":"<p>Initialize a dictionary to store edges for cross-validation.</p> <p>:param n_folds: Number of outer folds. :param n_features: Number of features in the data. :return: Dictionary to store edges.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.load_cv_results","title":"<code>load_cv_results(folder)</code>  <code>staticmethod</code>","text":"<p>Load cross-validation results from a CSV file.</p> <p>:param folder: Directory containing the results file. :return: DataFrame with the loaded results.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.save_network_strengths","title":"<code>save_network_strengths()</code>","text":"<p>Save network strengths to CSV.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.save_predictions","title":"<code>save_predictions()</code>","text":"<p>Save predictions to CSV.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.store_metrics","title":"<code>store_metrics(metrics, params, fold, param_id)</code>","text":"<p>Update metrics DataFrame with new metrics and parameters.</p> <p>:param metrics: Dictionary with computed metrics. :param params: Best hyperparameters from inner cross-validation. :param fold: Current fold number. :return: Updated metrics DataFrame.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.store_predictions","title":"<code>store_predictions(y_pred, y_true, params, fold, param_id, test_indices)</code>","text":"<p>Update predictions DataFrame with new predictions and parameters.</p> <p>:param y_pred: Predicted values. :param y_true: True values. :param params: Best hyperparameters from inner cross-validation. :param fold: Current fold number. :return: Updated predictions DataFrame.</p>"},{"location":"api/results_manager/#cccpm.results_manager.ResultsManager.update_results_directory","title":"<code>update_results_directory(output_dir)</code>","text":"<p>Determine the directory to save results.</p> <p>:param output_dir: :return: Results directory path.</p>"},{"location":"examples/simulated_data/","title":"Simulated Data","text":""},{"location":"examples/simulated_data/#example-code","title":"Example Code","text":"<p>Here is an example of how to generate simulated data: Python<pre><code>import numpy as np\nfrom sklearn.model_selection import ShuffleSplit, RepeatedKFold\n\nfrom cccpm import CPMRegression\nfrom cccpm.simulation.simulate_simple import simulate_confounded_data_chyzhyk\nfrom cccpm.edge_selection import PThreshold, UnivariateEdgeSelection\n\n\nX, y, covariates = simulate_confounded_data_chyzhyk(n_samples=1000, n_features=105, link_type='direct_link')\nunivariate_edge_selection = UnivariateEdgeSelection(edge_statistic='pearson',\n                                                    edge_selection=[PThreshold(threshold=[0.05, 0.01],\n                                                                               correction=[None])],\n                                                    t_test_filter=False)\n\ncpm = CPMRegression(results_directory='./tmp/example_simulated_data',\n                    cv=RepeatedKFold(n_splits=2, n_repeats=1, random_state=42),\n                    edge_selection=univariate_edge_selection,\n                    inner_cv=ShuffleSplit(n_splits=2, test_size=0.2, random_state=42),\n                    n_permutations=2,\n                    #atlas_labels='atlas_labels.csv',\n                    select_stable_edges=False)\n\ncpm.run(X=X, y=y, covariates=covariates)\n</code></pre></p>"},{"location":"examples/simulated_data/#example-output","title":"Example Output","text":"<p>Check out the interactive results generated by <code>cccpm</code>:</p> <p>     View Full Screen (New Tab)  </p>"}]}